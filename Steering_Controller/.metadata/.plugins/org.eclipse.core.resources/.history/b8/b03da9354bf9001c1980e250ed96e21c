/*
 * main.c
 *
 *  Created on: 2022 Apr 25 09:31:37
 *  Author: lukas
 */
#include "DAVE.h"                 //Declarations from DAVE Code Generation (includes SFR declaration)
#include <math.h>

#include "Globals.h"
#include "other_functions.h"
#include "DEFINE_CONST.h"
#include "Steering_servos.h"
#include "Driving_dynamics.h"
#include "CAN.h"
#include "Ultrasonic_Collision_Avoidance.h"

// Var MODES
volatile uint8_t RC_controll = 1; // if 1 RC controll


//VAR CAN
CAN_NODE_STATUS_t init_status;
int CAN_OK = 0;


float avg_Speeds = 0;

float trajctory_x = 0, trajctory_y = 0;
float Trajctory[2] = {0, 0};
float trajctory_Angel = 0;


// Var RC
uint8_t RC_Signal_OK = 0, RC_Signal_not_OK_counter = 0; // 0 no ok 1 OK
uint32_t  captured_time_Steering=0, captured_time_Speed=0;
uint8_t RC_no_Speed_data_counter = 0, RC_no_Steering_data_counter = 0;
float RC_Speed = 0, RC_Steering = 0;
#define RC_NP_SPEED  1500000
#define RC_NP_STEERING  1540000
float RC_Speed_ns_to_mps = 0.00000125;
float RC_Steering_ns_to_deg = 0.00021;

volatile uint32_t RC_gear_100us_counter = 0, RC_AUX1_100us_counter = 0;
volatile uint8_t RC_Gear_state = 2, RC_AUX1_state = 2;
volatile uint8_t RC_Gear_duty = 2, RC_Gear_duty_OLD =2, RC_AUX1_duty = 2;
uint8_t RC_Speed_Stop = 1;

// FUNCTIONS
void RC_Recive(void);

void Collision_voidance();
void Trajcetory_calc();


int main(void)
{
  DAVE_STATUS_t status;

  status = DAVE_Init();           /* Initialization of DAVE APPs  */

  if (status != DAVE_STATUS_SUCCESS)
  {
    /* Placeholder for error handler code. The while loop below can be replaced with an user error handler. */
    XMC_DEBUG("DAVE APPs initialization failed\n");

    while(1U)
    {

    }
  }

  //Initialization of CAN
  	//CAN_NODE_STATUS_t init_status;
  	init_status = CAN_NODE_Init(&CAN_NODE_0);

  	if (init_status != CAN_NODE_STATUS_SUCCESS) {
  		XMC_DEBUG("CAN initialization failed\n");
  	}
  	else{
  		CAN_OK = 1;
  	}

  	// watchdog
  	WATCHDOG_Start();

  /* Placeholder for user application code. The while loop below can be replaced with user application code. */
  while(1U)
  {
	//Servo_NP_setting();	  // nutral point servo setting
  }
}







void Watchdog_Handler(void) // to do restates if can is not working a problem wenn power from the buck or plab supplie but ok like this
{
  WATCHDOG_ClearAlarm(); /* Clear the alarm event */
  DIGITAL_IO_SetOutputHigh(&WATCHDOG_LED_BLUE);
}


void INTERRUPT_TIMER_10us_ISR(void){ // every 1ms so 10kHz
	if(RC_Gear_state == 1)RC_gear_100us_counter ++;
	if(RC_AUX1_state == 1)RC_AUX1_100us_counter ++;
}



void RC_Recive(void){

	CAPTURE_Start(&CAPTURE_RC_Steering);
	CAPTURE_Start(&CAPTURE_RC_Speed);

	CAPTURE_GetCapturedTimeInNanoSec(&CAPTURE_RC_Steering, &captured_time_Steering);
	CAPTURE_GetCapturedTimeInNanoSec(&CAPTURE_RC_Speed, &captured_time_Speed);

	if(RC_Speed_Stop == 1){
		if((captured_time_Speed >= 1000000) && (captured_time_Speed <= 2000000)){
		  RC_Speed = ((double)captured_time_Speed - RC_NP_SPEED) * RC_Speed_ns_to_mps; // form +-0.6m/s
		  if((RC_Speed < 0.1) && (RC_Speed > -0.1)) RC_Speed = 0; // to have accutal 0
		  RC_no_Speed_data_counter = 0;
		}
		else{
			RC_no_Speed_data_counter ++;
		}
	}
	else RC_Speed = 0;

	if((captured_time_Steering >= 1000000) && (captured_time_Steering <= 2000000)){
	  RC_Steering = (((double)captured_time_Steering - RC_NP_STEERING) * RC_Steering_ns_to_deg); // form +-90m/s
	  if((RC_Steering < 2) && (RC_Steering > -2)) RC_Steering = 0; // to have accutal 0
	  RC_no_Steering_data_counter = 0;
	}
	else{
	  RC_no_Steering_data_counter ++;
	}

	if(RC_no_Speed_data_counter > 20 || RC_no_Steering_data_counter > 20 ){ // internall values not ok
	  DIGITAL_IO_SetOutputLow(&RC_no_data_LED);
	  RC_no_Speed_data_counter = 20;
	  RC_no_Steering_data_counter = 20;

	  //set gobal vars 0
	  Driving_speed = 0;
	  Steering_direction = 0;
	}
	else{ // values filternig
	  DIGITAL_IO_SetOutputHigh(&RC_no_data_LED);

	  //set gobal vars stanart
	  Driving_speed = RC_Speed;
	  Steering_direction = RC_Steering;
	}

	New_Input = 1; //goalb var to tell it that there in new data to calculate
}

void RC_Connected_ISR(void){

	if(RC_controll == 1){

		RC_Gear_state =  PIN_INTERRUPT_GetPinValue(&RC_Connected); // pin haig or low

		if(RC_Gear_state == 0){// do nothing during high

			RC_Recive(); // get speed and steering data

			uint32_t RC_Gear_on_time_100us = RC_gear_100us_counter;
			RC_gear_100us_counter = 0;

			if((80 < RC_Gear_on_time_100us) && (RC_Gear_on_time_100us < 150)) RC_Gear_duty= 0;
			else if ((150 < RC_Gear_on_time_100us) && (RC_Gear_on_time_100us < 210)) RC_Gear_duty = 1;
			else RC_Gear_duty = 2;


			if(modeswitch_colldown == 0){
				if(RC_Gear_duty == 0 && RC_Gear_duty_OLD == 1){
					Steering_mode ++;
					if(Steering_mode > 5)Steering_mode = 0;
					modeswitch_colldown = 10;
				}
			}
			else modeswitch_colldown--;
			RC_Gear_duty_OLD = RC_Gear_duty;
		}
	}
}

void RC_AUX1_ISR(void){
	if(RC_controll == 1){
		RC_AUX1_state =  PIN_INTERRUPT_GetPinValue(&RC_AUX1); // pin haig or low

		if(RC_AUX1_state == 0){// do nothing during high
			uint32_t RC_AUX1_on_time_100us = RC_AUX1_100us_counter;
			RC_AUX1_100us_counter = 0;

			if((80 < RC_AUX1_on_time_100us) && (RC_AUX1_on_time_100us < 150)) RC_AUX1_duty= 0;
			else if ((150 < RC_AUX1_on_time_100us) && (RC_AUX1_on_time_100us < 210)) RC_AUX1_duty = 1;
			else RC_AUX1_duty = 2;


			if(RC_AUX1_duty == 1)RC_Speed_Stop = 1;
			else RC_Speed_Stop = 0;
		}
	}
}

void TIMER_CONTROL_ISR(void){
	DIGITAL_IO_SetOutputHigh(&CALC_TIME_INDICATOR);
	mode_led(Steering_mode);

	if(RC_controll == 1){
		if( NO_New_Input_counter > 9){
			DIGITAL_IO_SetOutputLow(&RC_no_data_LED);
		}
	}


	if(New_Input == 1){
	Steering_Function(Steering_direction, Driving_speed, Steering_mode);
	NO_New_Input_counter = 0;

	}
	else{
		NO_New_Input_counter ++;
		if( NO_New_Input_counter > 10){
			NO_New_Input_counter = 10;

			  Steering_Angles[0] = 0;
			  Steering_Angles[1] = 0;
			  Steering_Angles[2] = 0;
			  Steering_Angles[3] = 0;

			  Speeds[0] = 0;
			  Speeds[1] = 0;
			  Speeds[2] = 0;
			  Speeds[3] = 0;
		}
	}

	//set Angles PWM
	Steering_set_Angles(Steering_Angles);

	//Trajcetory_calc();


	//Collision_voidance();

	//send traget speeds to inverter
	CAN_send_Speeds(Speeds);

	//
	if(reset_distance == 1){
		reset_distance = 0;
		uint8_t all[4] = {1,1,1,1};
		CAN_reset_distance(all);
	}


	DIGITAL_IO_SetOutputLow(&CALC_TIME_INDICATOR);
}

/*

void Trajcetory_calc(){

	avg_Speeds = average(Speeds,4);

	switch(Steering_mode) // options 'Front'; 'Rear'; '4_Wheel'; 'Carb'; 'Rotate'
		{
			case FRONT://#############################################################
				//trajctory_x =
				break;

			case BACK:// rear #############################################################


			case ALL_WHEEL: // 4 wheel #############################################################

				break;

			case CRAB:  //carb //#############################################################
				trajctory_x = avg_Speeds * cos(Steering_Angles[0] / RAD_TO_DEG);
				trajctory_y = avg_Speeds * sin(Steering_Angles[0] / RAD_TO_DEG);
				trajctory_Angel = Steering_Angles[0];

				break;

			case ROTATE: // rotate ############################################################

				break;

			default :

			trajctory_x = 0;
			trajctory_y = 0;
		}

	//trajctory_Angel = cos(trajctory_x / trajctory_y);
	Trajctory[0] = trajctory_x;
	Trajctory[1] = trajctory_y;

}

*/





